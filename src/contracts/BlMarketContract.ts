/**
 * This file was automatically generated by cosmwasm-typescript-gen@0.3.6.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the cosmwasm-typescript-gen generate command to regenerate this file.
 */

import { CosmWasmClient, ExecuteResult, SigningCosmWasmClient } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
export type Addr = string;
export interface ConfigResponse {
  market_count: number;
  owner: Addr;
  ptoken_code_id: number;
  [k: string]: unknown;
}
export interface Config {
  owner: Addr;
  protocol_admin: Addr;
  protocol_rewards_collector_address: Addr;
  ptoken_code_id: number;
  [k: string]: unknown;
}
export type ExecuteMsg =
  | {
      receive: Cw20ReceiveMsg;
    }
  | {
      update_config: {
        config: ConfigParams;
        [k: string]: unknown;
      };
    }
  | {
      init_asset: {
        asset: Asset;
        asset_params: AssetParams;
        asset_symbol?: string | null;
        [k: string]: unknown;
      };
    }
  | {
      __init_asset_token_callback: {
        reference: number[];
        [k: string]: unknown;
      };
    }
  | {
      update_asset: {
        asset: Asset;
        asset_params: AssetParams;
        [k: string]: unknown;
      };
    }
  | {
      deposit_native: {
        denom: string;
        on_behalf_of?: string | null;
        [k: string]: unknown;
      };
    }
  | {
      withdraw: {
        amount?: Uint128 | null;
        asset: Asset;
        [k: string]: unknown;
      };
    }
  | {
      borrow: {
        amount: Uint128;
        asset: Asset;
        recipient?: string | null;
        [k: string]: unknown;
      };
    }
  | {
      repay_native: {
        denom: string;
        on_behalf_of?: string | null;
        [k: string]: unknown;
      };
    };
export type Uint128 = string;
export type Binary = string;
export type Asset =
  | {
      cw20: {
        contract_addr: string;
        [k: string]: unknown;
      };
    }
  | {
      native: {
        denom: string;
        [k: string]: unknown;
      };
    };
export type Decimal = string;
export type InterestRateModelParams = {
  linear: LinearInterestRateModelParams;
};
export interface Cw20ReceiveMsg {
  amount: Uint128;
  msg: Binary;
  sender: string;
  [k: string]: unknown;
}
export interface ConfigParams {
  owner?: string | null;
  protocol_admin?: string | null;
  protocol_rewards_collector_address?: string | null;
  ptoken_code_id?: number | null;
  [k: string]: unknown;
}
export interface AssetParams {
  active?: boolean | null;
  borrow_enabled?: boolean | null;
  deposit_enabled?: boolean | null;
  initial_borrow_rate?: Decimal | null;
  interest_rate_model_params?: InterestRateModelParams | null;
  liquidation_bonus?: Decimal | null;
  liquidation_threshold?: Decimal | null;
  max_loan_to_value?: Decimal | null;
  reserve_factor?: Decimal | null;
  [k: string]: unknown;
}
export interface LinearInterestRateModelParams {
  base: Decimal;
  optimal_utilization_rate: Decimal;
  slope_1: Decimal;
  slope_2: Decimal;
  [k: string]: unknown;
}
export interface InstantiateMsg {
  config: ConfigParams;
  [k: string]: unknown;
}
export type AssetType = "cw20" | "native";
export interface MarketInfo {
  asset_label: string;
  asset_reference: number[];
  asset_type: AssetType;
  cw20_token_address: Addr;
  denom: string;
  [k: string]: unknown;
}
export type InterestRateModel = {
  linear: {
    params: LinearInterestRateModelParams;
    [k: string]: unknown;
  };
};
export interface MarketResponse {
  active: boolean;
  asset_type: AssetType;
  borrow_enabled: boolean;
  borrow_index: Decimal;
  borrow_rate: Decimal;
  debt_total_scaled: Uint128;
  deposit_enabled: boolean;
  index: number;
  indexes_last_updated: number;
  interest_rate_model: InterestRateModel;
  liquidation_bonus: Decimal;
  liquidation_threshold: Decimal;
  liquidity_index: Decimal;
  liquidity_rate: Decimal;
  max_loan_to_value: Decimal;
  ptoken_address: Addr;
  reserve_factor: Decimal;
  [k: string]: unknown;
}
export interface Market {
  active: boolean;
  asset_type: AssetType;
  borrow_enabled: boolean;
  borrow_index: Decimal;
  borrow_rate: Decimal;
  debt_total_scaled: Uint128;
  deposit_enabled: boolean;
  index: number;
  indexes_last_updated: number;
  interest_rate_model: InterestRateModel;
  liquidation_bonus: Decimal;
  liquidation_threshold: Decimal;
  liquidity_index: Decimal;
  liquidity_rate: Decimal;
  max_loan_to_value: Decimal;
  ptoken_address: Addr;
  reserve_factor: Decimal;
  [k: string]: unknown;
}
export interface MarketsListResponse {
  markets_list: MarketInfo[];
  [k: string]: unknown;
}
export type QueryMsg =
  | {
      config: {
        [k: string]: unknown;
      };
    }
  | {
      market: {
        asset: Asset;
        [k: string]: unknown;
      };
    }
  | {
      markets_list: {
        [k: string]: unknown;
      };
    }
  | {
      user_collateral: {
        user_address: string;
        [k: string]: unknown;
      };
    }
  | {
      user_position: {
        user_address: string;
        [k: string]: unknown;
      };
    };
export interface UserCollateralResponse {
  collateral: UserAssetCollateralResponse[];
  [k: string]: unknown;
}
export interface UserAssetCollateralResponse {
  asset_label: string;
  asset_reference: number[];
  asset_type: AssetType;
  denom: string;
  enabled: boolean;
  [k: string]: unknown;
}
export type UserHealthStatus =
  | "not_borrowing"
  | {
      borrowing: Decimal;
    };
export interface UserPositionResponse {
  health_status: UserHealthStatus;
  max_debt_in_usd: Uint128;
  total_collateral_in_usd: Uint128;
  total_collateralized_debt_in_usd: Uint128;
  total_debt_in_usd: Uint128;
  weighted_liquidation_threshold_in_usd: Uint128;
  [k: string]: unknown;
}
export interface BlMarketReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ConfigResponse>;
  market: ({ asset }: { asset: object }) => Promise<MarketResponse>;
  marketsList: () => Promise<MarketsListResponse>;
  userCollateral: ({ userAddress }: { userAddress: string }) => Promise<UserCollateralResponse>;
  userPosition: ({ userAddress }: { userAddress: string }) => Promise<UserPositionResponse>;
}
export class BlMarketQueryClient implements BlMarketReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.market = this.market.bind(this);
    this.marketsList = this.marketsList.bind(this);
    this.userCollateral = this.userCollateral.bind(this);
    this.userPosition = this.userPosition.bind(this);
  }

  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {},
    });
  };
  market = async ({ asset }: { asset: object }): Promise<MarketResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      market: {
        asset,
      },
    });
  };
  marketsList = async (): Promise<MarketsListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      markets_list: {},
    });
  };
  userCollateral = async ({ userAddress }: { userAddress: string }): Promise<UserCollateralResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      user_collateral: {
        user_address: userAddress,
      },
    });
  };
  userPosition = async ({ userAddress }: { userAddress: string }): Promise<UserPositionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      user_position: {
        user_address: userAddress,
      },
    });
  };
}
export interface BlMarketInterface extends BlMarketReadOnlyInterface {
  contractAddress: string;
  sender: string;
  receive: (
    {
      amount,
      msg,
      sender,
    }: {
      amount: string;
      msg: string;
      sender: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: readonly Coin[],
  ) => Promise<ExecuteResult>;
  updateConfig: (
    {
      config,
    }: {
      config: ConfigParams;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: readonly Coin[],
  ) => Promise<ExecuteResult>;
  initAsset: (
    {
      asset,
      assetParams,
      assetSymbol,
    }: {
      asset: Asset;
      assetParams: AssetParams;
      assetSymbol?: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: readonly Coin[],
  ) => Promise<ExecuteResult>;
  initAssetTokenCallback: (
    {
      reference,
    }: {
      reference: number[];
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: readonly Coin[],
  ) => Promise<ExecuteResult>;
  updateAsset: (
    {
      asset,
      assetParams,
    }: {
      asset: Asset;
      assetParams: AssetParams;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: readonly Coin[],
  ) => Promise<ExecuteResult>;
  depositNative: (
    {
      denom,
      onBehalfOf,
    }: {
      denom: string;
      onBehalfOf?: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: readonly Coin[],
  ) => Promise<ExecuteResult>;
  withdraw: (
    {
      amount,
      asset,
    }: {
      amount?: Uint128;
      asset: Asset;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: readonly Coin[],
  ) => Promise<ExecuteResult>;
  borrow: (
    {
      amount,
      asset,
      recipient,
    }: {
      amount: Uint128;
      asset: Asset;
      recipient?: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: readonly Coin[],
  ) => Promise<ExecuteResult>;
  repayNative: (
    {
      denom,
      onBehalfOf,
    }: {
      denom: string;
      onBehalfOf?: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: readonly Coin[],
  ) => Promise<ExecuteResult>;
}
export class BlMarketClient extends BlMarketQueryClient implements BlMarketInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.receive = this.receive.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.initAsset = this.initAsset.bind(this);
    this.initAssetTokenCallback = this.initAssetTokenCallback.bind(this);
    this.updateAsset = this.updateAsset.bind(this);
    this.depositNative = this.depositNative.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.borrow = this.borrow.bind(this);
    this.repayNative = this.repayNative.bind(this);
  }

  receive = async (
    {
      amount,
      msg,
      sender,
    }: {
      amount: string;
      msg: string;
      sender: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: readonly Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        receive: {
          amount,
          msg,
          sender,
        },
      },
      fee,
      memo,
      funds,
    );
  };
  updateConfig = async (
    {
      config,
    }: {
      config: ConfigParams;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: readonly Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_config: {
          config,
        },
      },
      fee,
      memo,
      funds,
    );
  };
  initAsset = async (
    {
      asset,
      assetParams,
      assetSymbol,
    }: {
      asset: Asset;
      assetParams: AssetParams;
      assetSymbol?: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: readonly Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        init_asset: {
          asset,
          asset_params: assetParams,
          asset_symbol: assetSymbol,
        },
      },
      fee,
      memo,
      funds,
    );
  };
  initAssetTokenCallback = async (
    {
      reference,
    }: {
      reference: number[];
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: readonly Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        __init_asset_token_callback: {
          reference,
        },
      },
      fee,
      memo,
      funds,
    );
  };
  updateAsset = async (
    {
      asset,
      assetParams,
    }: {
      asset: Asset;
      assetParams: AssetParams;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: readonly Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_asset: {
          asset,
          asset_params: assetParams,
        },
      },
      fee,
      memo,
      funds,
    );
  };
  depositNative = async (
    {
      denom,
      onBehalfOf,
    }: {
      denom: string;
      onBehalfOf?: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: readonly Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        deposit_native: {
          denom,
          on_behalf_of: onBehalfOf,
        },
      },
      fee,
      memo,
      funds,
    );
  };
  withdraw = async (
    {
      amount,
      asset,
    }: {
      amount?: Uint128;
      asset: Asset;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: readonly Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        withdraw: {
          amount,
          asset,
        },
      },
      fee,
      memo,
      funds,
    );
  };
  borrow = async (
    {
      amount,
      asset,
      recipient,
    }: {
      amount: Uint128;
      asset: Asset;
      recipient?: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: readonly Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        borrow: {
          amount,
          asset,
          recipient,
        },
      },
      fee,
      memo,
      funds,
    );
  };
  repayNative = async (
    {
      denom,
      onBehalfOf,
    }: {
      denom: string;
      onBehalfOf?: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: readonly Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        repay_native: {
          denom,
          on_behalf_of: onBehalfOf,
        },
      },
      fee,
      memo,
      funds,
    );
  };
}
